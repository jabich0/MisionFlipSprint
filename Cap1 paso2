[
  {
    "id": "main_flow",
    "type": "tab",
    "label": "PharmaCold IoT Pipeline",
    "disabled": false,
    "info": "Flujo principal de procesamiento de telemetr√≠a"
  },
  {
    "id": "mqtt_in",
    "type": "mqtt in",
    "z": "main_flow",
    "name": "MQTT Subscribe",
    "topic": "pharmacold/trucks/telemetry",
    "qos": "1",
    "datatype": "json",
    "broker": "mqtt_broker",
    "x": 150,
    "y": 200,
    "wires": [["validate_json"]]
  },
  {
    "id": "validate_json",
    "type": "function",
    "z": "main_flow",
    "name": "Validate JSON Schema",
    "func": "// Validaci√≥n de schema\nconst requiredFields = [\n    'truck_id', 'timestamp', 'temperature',\n    'humidity', 'force_g', 'latitude', 'longitude',\n    'battery_level', 'cargo_type', 'package_id'\n];\n\ntry {\n    const data = msg.payload;\n    \n    // Verificar que sea un objeto\n    if (typeof data !== 'object' || data === null) {\n        node.error('Payload no es un objeto JSON v√°lido');\n        return null;\n    }\n    \n    // Verificar campos requeridos\n    const missingFields = requiredFields.filter(field => !(field in data));\n    if (missingFields.length > 0) {\n        node.error(`Campos faltantes: ${missingFields.join(', ')}`);\n        return null;\n    }\n    \n    // Validar tipos de datos\n    if (typeof data.temperature !== 'number' ||\n        typeof data.humidity !== 'number' ||\n        typeof data.force_g !== 'number' ||\n        typeof data.latitude !== 'number' ||\n        typeof data.longitude !== 'number' ||\n        typeof data.battery_level !== 'number') {\n        node.error('Tipos de datos incorrectos');\n        return null;\n    }\n    \n    // Validar rangos\n    if (data.temperature < -80 || data.temperature > 60) {\n        node.warn(`Temperatura fuera de rango: ${data.temperature}¬∞C`);\n    }\n    \n    if (data.force_g < 0 || data.force_g > 10) {\n        node.warn(`Fuerza G fuera de rango: ${data.force_g}`);\n    }\n    \n    if (data.battery_level < 0 || data.battery_level > 100) {\n        node.error(`Bater√≠a inv√°lida: ${data.battery_level}%`);\n        return null;\n    }\n    \n    // Enriquecer con metadata\n    data.processed_at = new Date().toISOString();\n    data.validation_status = 'passed';\n    \n    msg.payload = data;\n    node.status({fill: 'green', shape: 'dot', text: 'Validado OK'});\n    \n    return msg;\n    \n} catch (error) {\n    node.error(`Error en validaci√≥n: ${error.message}`);\n    node.status({fill: 'red', shape: 'ring', text: 'Error'});\n    return null;\n}",
    "outputs": 1,
    "x": 380,
    "y": 200,
    "wires": [["check_incident", "send_to_api"]]
  },
  {
    "id": "check_incident",
    "type": "switch",
    "z": "main_flow",
    "name": "Incident Detection",
    "property": "payload.incident_detected",
    "propertyType": "msg",
    "rules": [
      {"t": "nnull"},
      {"t": "null"}
    ],
    "checkall": "true",
    "repair": false,
    "x": 620,
    "y": 120,
    "wires": [["log_incident"], []]
  },
  {
    "id": "log_incident",
    "type": "debug",
    "z": "main_flow",
    "name": "üö® INCIDENT ALERT",
    "active": true,
    "tosidebar": true,
    "console": false,
    "tostatus": false,
    "complete": "payload",
    "x": 860,
    "y": 120,
    "wires": []
  },
  {
    "id": "send_to_api",
    "type": "http request",
    "z": "main_flow",
    "name": "POST to Ingest API",
    "method": "POST",
    "ret": "obj",
    "paytoqs": "ignore",
    "url": "http://ingest-api:8000/ingest",
    "tls": "",
    "persist": false,
    "proxy": "",
    "authType": "",
    "x": 640,
    "y": 200,
    "wires": [["check_api_response"]]
  },
  {
    "id": "check_api_response",
    "type": "switch",
    "z": "main_flow",
    "name": "Check Status Code",
    "property": "statusCode",
    "propertyType": "msg",
    "rules": [
      {"t": "eq", "v": "200", "vt": "str"},
      {"t": "eq", "v": "201", "vt": "str"},
      {"t": "else"}
    ],
    "checkall": "true",
    "repair": false,
    "x": 880,
    "y": 200,
    "wires": [["success_log"], ["success_log"], ["retry_logic"]]
  },
  {
    "id": "success_log",
    "type": "debug",
    "z": "main_flow",
    "name": "‚úÖ Success",
    "active": true,
    "tosidebar": true,
    "console": false,
    "tostatus": false,
    "complete": "payload",
    "x": 1100,
    "y": 180,
    "wires": []
  },
  {
    "id": "retry_logic",
    "type": "function",
    "z": "main_flow",
    "name": "Retry Logic",
    "func": "// Configuraci√≥n de reintentos\nconst MAX_RETRIES = 3;\nconst RETRY_DELAY = 5000; // 5 segundos\n\n// Inicializar contador si no existe\nif (!context.retries) {\n    context.retries = {};\n}\n\nconst messageId = msg.payload.truck_id + '_' + msg.payload.timestamp;\n\nif (!context.retries[messageId]) {\n    context.retries[messageId] = 0;\n}\n\ncontext.retries[messageId]++;\n\nif (context.retries[messageId] <= MAX_RETRIES) {\n    node.warn(`‚ö†Ô∏è  API Error. Reintento ${context.retries[messageId]}/${MAX_RETRIES}`);\n    node.status({\n        fill: 'yellow',\n        shape: 'ring',\n        text: `Retry ${context.retries[messageId]}`\n    });\n    \n    // Guardar en cola de reintentos\n    flow.set(`retry_${messageId}`, msg.payload);\n    \n    setTimeout(() => {\n        // Reenviar despu√©s del delay\n        return msg;\n    }, RETRY_DELAY);\n} else {\n    node.error(`‚ùå Max reintentos alcanzado para ${messageId}`);\n    node.status({fill: 'red', shape: 'dot', text: 'Failed'});\n    \n    // Guardar en Dead Letter Queue\n    flow.set(`dlq_${messageId}`, msg.payload);\n    \n    // Limpiar contador\n    delete context.retries[messageId];\n    \n    return null;\n}\n\nreturn msg;",
    "outputs": 1,
    "x": 1100,
    "y": 240,
    "wires": [["delay_before_retry"]]
  },
  {
    "id": "delay_before_retry",
    "type": "delay",
    "z": "main_flow",
    "name": "Wait 5s",
    "pauseType": "delay",
    "timeout": "5",
    "timeoutUnits": "seconds",
    "rate": "1",
    "nbRateUnits": "1",
    "rateUnits": "second",
    "randomFirst": "1",
    "randomLast": "5",
    "randomUnits": "seconds",
    "drop": false,
    "x": 640,
    "y": 280,
    "wires": [["send_to_api"]]
  },
  {
    "id": "mqtt_broker",
    "type": "mqtt-broker",
    "name": "Mosquitto Broker",
    "broker": "mosquitto",
    "port": "1883",
    "clientid": "nodered_client",
    "usetls": false,
    "protocolVersion": "4",
    "keepalive": "60",
    "cleansession": true,
    "birthTopic": "nodered/status",
    "birthQos": "1",
    "birthPayload": "online",
    "birthMsg": {},
    "closeTopic": "nodered/status",
    "closeQos": "1",
    "closePayload": "offline",
    "closeMsg": {},
    "willTopic": "nodered/status",
    "willQos": "1",
    "willPayload": "offline",
    "willMsg": {},
    "sessionExpiry": ""
  }
]
